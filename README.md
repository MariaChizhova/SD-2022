# Software Development course

## Описание архитектуры:
![Architecture](diagram.png)

В методе `Main` реализован основной цикл программы. Он считывает входную строку из терминала и передает ее парсеру. После этого последовательно вызываются методы классов, описанных далее.

Класс `Parser` содержит метод `parse`, выполняющий разбор командной строки на список сущностей (класс `Token`), которые могут представлять собой: 
строка (в том числе команда), подстановка `$`, объявление переменных `=` или `|` - пайплайны. 
Класс `Token` имеет методы `getType()` и `getValue()`, возвращающие тип и значение токена.
Поддерживает разбор и `''`, и `""`: `''` интерпретируется буквально, а `""` позволяют расширение переменной, `$` осуществляет подстановку переменных.

### Алгоритм разбора:

Разбиваем строку на список токенов, запускаем на нем алгоритм обработки:

В начале обработки для каждого токена проверяется, не является ли токен подстановкой - 
тогда из словаря переменных извлекается значение по ключу, если переменная не определена - пустая строка.
Всё что находится в одинарных кавычках разбирается как есть и является строкой.

Первый токен в списке токенов - название команды, либо название переменной.
Сначала проверяется, является ли выражение присваиванием: проверяется, что следующим токеном является `=`. 
Считаем, что название переменной - токен до знака `=`, 
значение переменной - выражение справа от `=` (список токенов от следующей позиции до токена пайпа или конца строки).
Создается экземпляр класса `Command` (`declartion`), который будет записывать в глобальный словарь `{"название переменной": "её вычесленное значение"}`.

Само значение до этапа вычисления тоже является командой, которую надо будет вычислить, но только если всё выражение присваивания не находится в пайплайне, 
иначе команда присваивания игнорируется, а потоки ввода-вывода зануляются.
Если следующий токен не `=`, это должна быть команда, и если данное название присутствует в списке поддерживаемых команд, 
то вызывается соответствующий метод `buildCommandByName`, принимающий список аргументов (список токенов от следующей позиции до токена пайпа или конца строки).
Иначе выполняется запуск подпроцесса.

Последовательность токенов обрабатывается в классы `Command`, разделяясь по символу `|`. 
Компонента `Commands` содержит описание того, как должны исполняться соответствующие команды. 
Каждая команда представляется отдельным классом `CommandName`, который наследуется от абстрактного класса `Command`. 
Каждый класс имеет метод `execute()`, который возвращает 0 в случае успешного исполнения. 
Также в этом классе имеются следующие поля: `stdin` и `stdout`, которые отвечают за потоки ввода-вывода.

После разбора токенов выполняется вычисление команд по порядку. `stdout` выполненной команды становится `stdin`'ом следующей.
`stdin` первой команды привязывается на время выполнения на `stdin` испольнительной системы (`python: sys.stdin`), `stdout` для последней команды соответствующе.


### Наследники абстрактного класса Command

* Команда `cat [FILE]` выводит на экран содержимое последовательности файлов, переданных в качестве аргументов. Если файлы отстутствуют, то тогда содержимое читается из потока ввода. Если же он пуст, то запускается интерактивный режим и выводит пользовательский ввод.
* Команда `echo`  - выводит на экран свой аргумент (или аргументы), если список аргументов пуст, то выводит пустую строку.
* Команда `wc [FILE]` выводит количество строк, слов и байт в последовательности файлов. Для каждого файла информация выводится отдельно, перед ней указывается название соответствующего файла.  Если файлы отстутствуют, то тогда содержимое читается из потока ввода.  Если же он пуст, то запускается интерактивный режим и выводит количество строк, слов и байт пользовательского ввода.
* Команда `pwd` печатает абсолютный путь до текущей директории.
* Команда `exit` завершает работу интерпретатора, а именно в методе execute вызывается метод exit(). При существовании субпроцессов отправляем им сигнал прерывания и если они не завершились - убиваем. 
* Команда `declartion` присваивает значение переменной. Соответственно, ее аргументы - название и значение переменной. 
* Команда `outercommand` - вызов внешних команд в случае, если введено что-то, что интерпретатор не знает. Создается новый поток, в котором выполняется процесс требуемой команды.  `stdin` передается либо с прошлой команды, либо подвязывается в `stdin` исполнительной системы, `stdout` аналогично. Так как мы выполнили подстановку до запуска команды, передавать `environment` с переменными в новый процесс не требуется.

Дожидаемся завершения команды. При успешном завершении (код возврата = 0) - ничего не делаем, при неудаче - обрабатываем исключение и сообщаем пользователю. 

Если переменные объявляются в пайплайне или встречается команда `exit`, то они будут проигнорированы.  

После исполнения всех необходимых команд, отображаем результат.

В процессе выполнения каждого шага обрабатываем ошибки.
